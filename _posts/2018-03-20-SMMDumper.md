**题目： When hardware meets software: a bulletproof solution to forensic memory acquisition**

**作者： Alessandro Reina, Aristide Fattori, Fabio Pagani, Lorenzo Cavallaro, Danilo Bruschi**

**单位： Università degli Studi di Milano and Royal Holloway, University of London**

**出版： ACSAC 2012**

# 解决问题：

1.    在数字取证和事件反应上，运行时的内存提取是重要手段。理由是持久性存储常用加密来保护对象，而运行时必然有明文大白于天下的时候。
2.    打开的套接字、文件和运行中的进程都是常见的抽取对象，也只能从内存中获取，但其状态又在持续变化，snapshot有一定难度。
3.    SMMDumper提供了原子化（事务性）地内存取证能力，使用SMM特权模式实现完整可靠地内存取证，并突破了4GB限制。
4.    原子性：取证的对象状态应一致，即不能被意外中断；可靠性：取证使用的代码和被取证对象的完整性不能被破坏。


# 贡献点（后三点是其工作，是否足够优秀，有争议）：

1.    使用固件技术实现完整可靠的内存取证，可抵挡一切恶意攻击；
2.    绕过4GB访问限制（PAE）；
3.    对内存取证的数据进行签名，验证完整性；
4.    使用QEMU实现原型，验证有效性和正确性。


# 相关工作：

*    基于软件：使用虚拟化隔离机制（如Xen），dom0可以将其他dom的内存映射到自己内存区域访问（共享内存机制），虽然不会被感知，但一致性无法保证；
*    基于硬件：使用专门的PCI设备，利用DMA获取内存，但可以配置IOMMU屏蔽DMA访问。

    1. HyperCheck周期性触发SMI，将其中的数据发送到远端服务器，但该方案需要安装专门的PCI设备，没有绕过4GB大小限制，对对象的完整性缺乏检查。
    2. HyperSleuth使用了虚拟化方案来手收集内存，缺点是攻击者可以干扰发送内存数据的IP包。


# 威胁模型：

1.    假设存在硬件，能保证SMI的触发，并将数据传给SMMDumper（该假设很强）；
2.    攻击者具备OS的root权限，可攻击同一网络的其他机器，发动网络攻击；
3.    不考虑攻击者可以获取智能卡设备（其藏有私钥），利用SMRAM漏洞，能接触硬件（如关闭系统，使用DMA将内存数据清空等）。


# 设计：
见图1。

1.    由一串特殊键盘序列触发SMI；
2.    进入SMM模式收集内存；
3.    使用智能卡提供签名，传给远端。
4.    使用PSE-36绕过4GB内存限制；
5.    将物理内存划分1KB大小，每次传1KB，使用自定义协议保证完整性。
6.    为了保证签名的私钥不泄露，使用智能卡来保护（使用了专门的物理硬件）。
7.    在SMM中实现简单的NIC驱动和UDP协议。


# 实现：

1.    使用Qemu 1.0.1来进行模拟；
2.    和我们一样，TX缓冲区不在SMRAM中，因为NIC无法访问SMRAM；
3.    传输6GB内存，需要144MB元数据，需要时间814′′。


# 未来工作：

1.    支持多处理架构，一个核执行ISR，进行内存取证，其他静默；
2.    恶意VMM可以拦截rsm指令，避免4GB以上内存被寻址；
3.    在SMM中支持A-32e，实现超过64GB的索引。


# 评价：

1.    介绍部分逻辑写的不是很好，可能是我对SMM比较熟悉，其行文叙述逻辑比较平铺直叙，但不连贯。
2.    行文假设过多，设计上存在多处硬伤：键盘中断触发时内存没有过多变化，网络传输不会出错，智能卡与SMM的交互没有问题，网络传输时没有中间人攻击等，**本质是在设计上使用了过多东西（abuse），引入了很大的攻击面！**
3.    使用智能卡可能是当时的趋势吧，但是使用AESNI来保证完整性更具竞争力。
4.    **该方法无法取证swapped内存数据**。可惜的是，虽然使用md5保证传输数据的完整性，但对传输的丢包却做了假设，我们认为：使用TLS协议是目前恰当的选择。
